import{t as e}from"./jsx-runtime.CWlfk1IU.js";import{t}from"./Svg.8sPTxAw7.js";var n=e();const r=({addButtonLabel:e,addButtonOnClick:r,children:i})=>(0,n.jsxs)(`div`,{className:`relative`,children:[(0,n.jsx)(`div`,{className:`space-y-3`,children:i}),e&&r&&(0,n.jsx)(`button`,{type:`button`,onClick:r,className:`safe-margin-bottom fixed z-10 bottom-21 right-4 p-3 rounded-xl btn-primary shadow`,"aria-label":e,children:(0,n.jsx)(t,{name:`plus-squared`,className:`size-6`})})]});var i=async(e,t,n,r)=>await new Promise(i=>{let a=window.indexedDB?.open(e,n);if(!a){i(void 0);return}a.onerror=e=>{e.stopPropagation(),i(void 0)},a.onsuccess=()=>{let e=a.result;e.onversionchange=()=>{e.close()},i(e)},a.onupgradeneeded=e=>{let n=a.result;t.forEach(t=>{let i;i=n.objectStoreNames.contains(t)?e.target.transaction.objectStore(t):n.createObjectStore(t,{keyPath:`id`});let a=r?.[t];a&&Object.entries(a).forEach(([e,t])=>{i.indexNames.contains(e)||i.createIndex(e,t,{unique:!1})})});let o=e.target.transaction;o!==null&&(o.oncomplete=()=>{i(n)})},a.onblocked=()=>{}}),a=async(e,t,n,r)=>{await new Promise((i,a)=>{try{if(e===void 0){a(Error(`${t}: Transaction error`));return}let o=e.transaction([t],n);r(o.objectStore(t)),o.oncomplete=()=>{i(void 0)},o.onerror=n=>{n.stopPropagation(),e=void 0,a(o.error??Error(`${t}: Transaction error`))}}catch(n){e=void 0,a(n instanceof Error?n:Error(`${t}: Transaction error`))}})},o=(e,t,n)=>{let{version:r=1,indexes:o}=n??{},s,c=async()=>(s===void 0&&(s=await i(e,t,r,o)),s!==void 0);return{get:async(e,t)=>await c()?await new Promise(n=>{a(s,t,`readonly`,t=>{let r=t.get(e);r.onsuccess=()=>{n(r.result??null)},r.onerror=e=>{e.stopPropagation(),n(null)}}).catch(()=>{n(null)})}):null,getAll:async e=>await c()?await new Promise(t=>{a(s,e,`readonly`,e=>{let n=e.getAll();n.onsuccess=()=>{t(n.result)},n.onerror=e=>{e.stopPropagation(),t([])}}).catch(()=>{t([])})}):[],getAllByIndex:async(e,t,n)=>await c()?await new Promise(r=>{a(s,e,`readonly`,e=>{let i=e.index(t).getAll(n);i.onsuccess=()=>r(i.result),i.onerror=e=>{e.stopPropagation(),r([])}}).catch(()=>r([]))}):[],put:async(e,t)=>{await c()&&a(s,t,`readwrite`,t=>{t.put(e)}).catch(()=>{})},delete:async(e,t)=>{await c()&&a(s,t,`readwrite`,t=>{t.delete(e)}).catch(()=>{})},clear:async e=>{await c()&&a(s,e,`readwrite`,e=>{e.clear()}).catch(()=>{})}}};const s=`clients`,c=`packages`,l=`attendance`;var u=o(`coaching-admin`,[s,c,l],{version:5,indexes:{[s]:{name:`name`},[c]:{clientId:`clientId`,date:`date`,remainingSessions:`remainingSessions`,clientIdAndRemainingSessions:[`clientId`,`remainingSessions`],clientIdAndDate:[`clientId`,`date`],remainingSessionsAndDate:[`remainingSessions`,`date`],clientIdAndRemainingSessionsAndDate:[`clientId`,`remainingSessions`,`date`]},[l]:{clientId:`clientId`,packageId:`packageId`,date:`date`,clientIdAndDate:[`clientId`,`date`],packageIdAndDate:[`packageId`,`date`]}}}),d=e=>({getAll:async()=>await f.getAll(e),get:async t=>await f.get(t,e),getAllByIndex:async(t,n)=>await f.getAllByIndex(e,t,n),put:async t=>{let n={...t,id:t.id??crypto.randomUUID()};return await f.put(n,e),n},delete:async t=>await f.delete(t,e),clear:async()=>await f.clear(e)});const f={...u,useTable:d},p=e=>[new Date(e).setHours(0,0,0,0),new Date(e).setHours(23,59,59,999)];var m=new Map;const h={get:(e,t)=>(m.has(e)||m.set(e,t().catch(t=>{throw m.delete(e),t})),m.get(e)),invalidate:e=>{m.delete(e)},invalidateByPrefix:e=>{for(let t of m.keys())t.startsWith(e)&&m.delete(t)}};var g=`attendance`,_=f.useTable(l),v={full:()=>{h.invalidateByPrefix(g)},all:()=>{h.invalidateByPrefix(`${g}:all`),h.invalidateByPrefix(`${g}:dateRange`)},byId:e=>{h.invalidateByPrefix(`${g}:${e}`)},byClientId:e=>{h.invalidateByPrefix(`${g}:client${e?`:${e}`:``}`)},byPackageId:e=>{h.invalidateByPrefix(`${g}:package${e?`:${e}`:``}`)},by:({id:e,clientId:t,packageId:n})=>{e&&v.byId(e),t&&v.byClientId(t),n&&v.byPackageId(n)}};const y={getById:e=>h.get(`${g}:${e}`,()=>_.get(e)),getAll:()=>h.get(`${g}:all`,()=>_.getAll()),getByClientId:e=>h.get(`${g}:client:${e}`,()=>_.getAllByIndex(`clientId`,e)),getByDateRange:(e,t)=>{let[n]=p(e),[,r]=p(t??e);return h.get(`${g}:dateRange:${n}:${r}`,()=>_.getAllByIndex(`date`,IDBKeyRange.bound(n,r)))},getByPackageId:e=>h.get(`${g}:package:${e}`,()=>_.getAllByIndex(`packageId`,e)),create:async e=>{let t=await C.getActiveByClientId(e.clientId);if(t.length===0)throw Error(`У клиента нет активных пакетов`);let n=t[0],r=await _.put({date:e.date||Date.now(),clientId:e.clientId,packageId:n.id,sessionCost:n.pricePerSession});return await C.updateRemainingSessions(n.id,-1),v.by(r),v.all(),r},createSingleSession:async(e,t,n)=>{let r=await _.put({date:e,clientId:`single-session`,packageId:`single-session`,sessionCost:t,clientName:n});return v.by(r),v.all(),r},import:async e=>{await Promise.all(e.map(async e=>await _.put(e))),v.full()},delete:async(e,t=!0)=>{let n=await y.getById(e);n&&(t&&await C.updateRemainingSessions(n.packageId,1),await _.delete(e),v.by(n),v.all())},deleteByPackageId:async(e,t=!1)=>{let n=await y.getByPackageId(e);await Promise.all(n.map(async e=>{t&&await C.updateRemainingSessions(e.packageId,1),await _.delete(e.id),v.byId(e.id)})),v.by({packageId:n[0]?.packageId,clientId:n[0]?.clientId}),v.all()},deleteByClientId:async(e,t=!1)=>{let n=await _.getAllByIndex(`clientId`,e);await Promise.all(n.map(async e=>{t&&await C.updateRemainingSessions(e.packageId,1),await _.delete(e.id),v.byId(e.id)})),v.by({packageId:n[0]?.packageId,clientId:n[0]?.clientId}),v.all()},clear:async()=>{await _.clear(),v.full()}};var b=`packages`,x=f.useTable(c),S={full:()=>{h.invalidateByPrefix(b)},all:()=>{h.invalidateByPrefix(`${b}:all`),h.invalidateByPrefix(`${b}:dateRange`)},byId:e=>{h.invalidateByPrefix(`${b}:${e}`)},byClientId:e=>{h.invalidateByPrefix(`${b}:client${e?`:${e}`:``}`)}};const C={getById:e=>h.get(`${b}:${e}`,()=>x.get(e)),getAll:()=>h.get(`${b}:all`,()=>x.getAll()),getAllActive:()=>h.get(`${b}:all:active`,()=>x.getAllByIndex(`remainingSessions`,IDBKeyRange.lowerBound(1))),getByClientId:e=>h.get(`${b}:client:${e}`,()=>x.getAllByIndex(`clientId`,e)),getActiveByClientId:e=>h.get(`${b}:client:${e}:active`,async()=>x.getAllByIndex(`clientIdAndRemainingSessions`,IDBKeyRange.lowerBound([e,1]))),getByDateRange:(e,t)=>{let[n]=p(e),[,r]=p(t??e);return h.get(`${b}:dateRange:${n}:${r}`,()=>x.getAllByIndex(`date`,IDBKeyRange.bound(n,r)))},create:async e=>{let t=await x.put({...e,remainingSessions:e.remainingSessions??e.totalSessions,pricePerSession:e.cost/e.totalSessions});return console.log(`Created package:`,t),S.byId(t.id),S.byClientId(e.clientId),S.all(),t},import:async e=>{await Promise.all(e.map(async e=>await x.put(e))),S.full()},update:async(e,t)=>{let n=await x.get(e);if(!n)return null;let r={...n,...t};return(t.cost!==void 0||t.totalSessions!==void 0)&&(r.pricePerSession=r.cost/r.totalSessions),S.byId(n.id),S.byClientId(n.clientId),r.id!==n.id&&S.byId(r.id),r.clientId!==n.clientId&&S.byClientId(r.clientId),S.all(),await x.put(r)},delete:async(e,t=!0)=>{let n=await C.getById(e);if(!n)return null;t&&await y.deleteByPackageId(e,!1),await x.delete(e),S.byId(e),S.byClientId(n.clientId),S.all()},deleteByClientId:async(e,t=!1)=>{let n=await x.getAllByIndex(`clientId`,e);await Promise.all(n.map(async e=>{t&&await y.deleteByPackageId(e.id,!1),await C.delete(e.id,t),S.byId(e.id)})),S.byClientId(e),S.all()},updateRemainingSessions:async(e,t)=>{let n=await x.get(e);if(!n)return null;let r=n.remainingSessions+t;if(r<0||r>n.totalSessions)throw Error(`Невозможно обновить оставшиеся сессии: превышены допустимые границы`);let i={...n,remainingSessions:r};return S.byId(i.id),S.byClientId(i.clientId),S.all(),await x.put(i)},clear:async()=>{await x.clear(),S.full()},clearInactive:async()=>{let e=await x.getAllByIndex(`remainingSessions`,IDBKeyRange.only(0));await Promise.all(e.map(async e=>{await x.delete(e.id),S.byId(e.id),S.byClientId(e.clientId)})),S.all()}};export{f as a,s as i,y as n,r as o,h as r,C as t};